<h1 style="margin-top: 0px;">Workflow control with Python-based external algorithms</h1>
<style>
  #myol {
    margin-left: 5%;
    list-style: none outside none;
  }
  #myol li {
    counter-increment: item;
    list-style-type: none;
    margin-bottom: 5px;
  }
  #myol li:before {
    margin-right: 10px;
    content: counter(item)")";
    color: white;
    text-align: center;
    display: inline-block;
  }

</style>

<style>
  #mytt {
    font-family:'Lucida Console', monospace;
  }
</style>

<!-- Code snippets -->
<style>
  #mycode {
  font-family: 'Lucida Console',monospace;
  font-color: white;
  background-color: #525254;
  }
</style>

<!-- File names -->
<style>
  #myfn {
  font-family: 'Lucida Console',monospace;
  }
</style>

<style>
  #myi {
    font-style: italic;
  }
</style>

<style>
  #myb {
    font-weight: bold;
  }
</style>

<p>
  The full source code for this tutorial use case be downloaded here:
  <a href="http://www.mcs.anl.gov/~emews/files/UC2.zip">UC2.zip</a>.
</p>

<p>

  Due to the highly non-linear relationship between ABM input parameters and model outputs,
  as well as feedback loops and emergent behaviors, large-parameter spaces of realistic ABMs
  cannot generally be explored via brute force methods, such as full-factorial experiments,
  space-filling sampling techniques, or any other a priori determined sampling schemes.
  This is where adaptive, heuristics-based approaches for model exploration (ME) are useful and this is the focus of the next two use cases.
</p>
<p>
In (<modal-data data="plugins/Tutorial-View/tutorial/refs/ozik_many_2015.html">Ozik, Collier, and Wozniak 2015</modal-data>)
  we describe an inversion of control (IoC) approach enabled by resident Python tasks in Swift/T and simple
  queue-based interfaces for passing parameters and
  simulation results, where a metaheuristic method, a genetic algorithm (GA),
  is
  used to control a large workflow. This workflow structure was made more general and resulted in the EMEWS framework.
  In this second use case we describe how this IoC workflow is implemented with the EQ/Py extension. The following is the overall EMEWS workflow structure for this use case.
</p>
<p>
  <img src="plugins/Tutorial-View/tutorial/img/EMEWS_figure_UC2.png" alt="EMEWS Figure UC2" height="300">
</p>

<p>
We use a GA model exploration module developed with the Python DEAP library (<modal-data data="plugins/Tutorial-View/tutorial/refs/fortin_deap_2012.html">Fortin et al. 2012</modal-data>). We also use the same Java-based JZombies model from the <modal-data data="plugins/Tutorial-View/tutorial/uc1.html" ref="jzombies">Use Case 1 Tutorial</modal-data>. The GA is used to automatically discover the best input parameter combinations which yield the maximum number of surviving humans. For each parameter combination, this "fitness" metric is calculated by averaging over a number of stochastic variations. Unlike the example presented in <modal-data data="plugins/Tutorial-View/tutorial/uc1.html" ref="finding_best">Use Case 1 Tutorial</modal-data>, we aren't specifying an a priori set of parameter combinations for evaluation. Rather, we are using the GA heuristic to dynamically explore the input parameter space of the JZombies model. With EMEWS, this model exploration (ME) can be done at scale, without needing to modify either the ME code or the model code.
</p>

<h2> EQ/Py with EMEWS </h2>
<!--
<p>
  Resident tasks, which retain state, are accessed via their worker location so that the
algorithm state can be repeatedly accessed.
</p>
 -->

<p>
  One unique aspect of the EMEWS framework is its ability to directly incorporate external libraries or code that implements model exploration algorithms. The benefit of using external libraries directly is threefold:
</p>
<p>
<ol id="myol">
            <li>There is no need to port the logic of a model exploration method into Swift/T,
  thereby removing the (possibly prohibitive) effort overhead and the possibility
  for translation errors.</li>
            <li>The latest methods from the many available
  model exploration toolkits (e.g., those in Section 2.2 of the <modal-data data="plugins/Tutorial-View/tutorial/refs/ozik_emews_2016.html">EMEWS Tutorial</modal-data>)
  can be easily compared with each other for utility and performance.</li>
            <li>The external libraries are not aware of their existence within the
  EMEWS framework, so methods developed without massively parallel computing
  resources in mind can be nonetheless utilized in such settings.</li>
          </ol>
</p>


<p>
As was discussed in the <modal-data data="plugins/Tutorial-View/tutorial/templating.html" ref="eqpy_section">EQ/Py section</modal-data> of the EMEWS Template tutorial, the EQ/Py extension provides an interface for interacting with Python-based resident tasks
at specific locations. The code that we present in this use case is directly adapted from the EQ/Py subtemplate, so readers who have completed the EMEWS Templates tutorial will already be familiar with the directory structure and template code.

<h2> EQ/Py swift script </h2>
<p>
The <open-code code="uc2/swift/swift_run_eqpy.swift">swift_run_eqpy.swift</open-code> file is the main swift file generated for the EQ/Py subtemplate. Here we discuss how this template file was modified for the current example.
</p>

<ul>
<li>Starting from lines <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="148" to="152">149-153</highlight-code> in the main function, we've modified the command line arguments that are sent to the swift script. </li>

<li>The <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="134" to="136"><tt id="mycode">run_prerequisites</tt></highlight-code> Swift function was implemented, using the same functionality as <modal-data data="plugins/Tutorial-View/tutorial/uc1.html" ref="utility_functions">cp_message_center in UC1</modal-data>. </li>

 <li>The arguments passed to the <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="103" to="104"><tt id="mycode">start</tt></highlight-code> function were modified to reflect the new information that is passed in via the command line.</li>

 <li>The <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="114" to="114"><tt id="mycode">algo_params</tt></highlight-code> string variable, which contains the information for initializing the Python resident task, was modified.</li>

<li> In the <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="54" to="54"><tt id="mycode">loop</tt></highlight-code> function the <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="55" to="57"><tt id="mycode">param_names</tt></highlight-code> string variable is added to track which parameters are being explored by the GA. This allows us to specify the subset of model parameters to explore.

 <li> In the <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="42" to="42"><tt id="mycode">obj</tt></highlight-code> function we call the <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="44" to="44"><tt id="mycode">create_upfs</tt></highlight-code> function (defined in a separate swift file <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="40" to="44">R_utils.swift</highlight-code>, discussed below) to generate stochastic variations of individual parameter combinations. These are stored in the string variable <tt id="mycode">upfs</tt> as semicolon separated sets of parameters. The string array <tt id="mycode">parameter_combos</tt> is created by <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="45" to="45">splitting</highlight-code> <tt id="mycode">upfs</tt> using semicolons as delimiters. Once the parameter combinations are <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="48" to="48">evaluated</highlight-code>, their average is <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="51" to="51">calculated</highlight-code>.
</li>

<li>In the <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="27" to="27"><tt id="mycode">run_obj</tt></highlight-code> function we removed the <tt id="mycode">out</tt> and <tt id="mycode">err</tt> files for tracking stdout and stderr (these can be included for debugging purposes). We define the path to the <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="32" to="32">script file</highlight-code> to run our model. Finally, we call the <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="35" to="35"><tt id="mycode">calc_obj</tt></highlight-code> function (also defined in <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="9" to="14">R_utils.swift</highlight-code> and discussed below) to calculate the fitness of the parameter combination <tt id="mycode">param_line</tt>.</li>

</ul>

<h2> R_utils swift script and swift script testing </h2>
<p>
The <open-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)">R_utils.swift</open-code> file was used to define utility functions used in the <open-code code="uc2/swift/swift_run_eqpy.swift">swift_run_eqpy.swift</open-code> file. The two functions implemented are <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="9" to="14"><tt id="mycode">calc_obj</tt></highlight-code> and <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="40" to="44"><tt id="mycode">create_upfs</tt></highlight-code>.
</p>

<!-- <h4> <tt id="mytt">calc_obj</tt> </h4> -->
<p>The <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="9" to="14"><tt id="mycode">calc_obj</tt></highlight-code> function is implemented just like the counting of humans was implemented in the <modal-data data="plugins/Tutorial-View/tutorial/uc1.html" ref="gather_results">Gathering the Results</modal-data> section of the Use Case 1 Tutorial. The only difference is that all of the relevant code is captured within the <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="9" to="14"><tt id="mycode">calc_obj</tt></highlight-code> function and that it is tested with the
<highlight-code code="uc2/swift/test/R_utils_tests.swift" color="rgba(255,255,255,0.3)" from="20" to="31"><tt id="mycode">test2</tt></highlight-code> function in R_utils_tests.swift. </p>
<p>In a multi-module and multi-language setting like EMEWS, it is crucial for separate modules to be tested individually before all of the components are assembled into a single workflow. For testing Swift code, the <highlight-code code="uc2/swift/test/R_utils_tests.swift" color="rgba(255,255,255,0.3)" from="24" to="24"><tt id="mycode">assert</tt></highlight-code> keyword is used to ensure that the expected results are returned from executing the code being tested.
The <tt id="mycode">test2</tt> function contains three separate tests to exercise the <tt id="mycode">calc_obj</tt> function. Each of these tests is passed a different path to a test data folder ("data", "data/d1", and "data/d2"), each containing three separate counts.csv files (<open-code code="uc2/swift/test/data/counts.csv"  color="rgba(255,255,255,0.3)">data/counts.csv</open-code>, <open-code code="uc2/swift/test/data/d1/counts.csv" color="rgba(255,255,255,0.3)">data/d1/counts.csv</open-code>, and <open-code code="uc2/swift/test/data/d2/counts.csv" color="rgba(255,255,255,0.3)">data/d2/counts.csv</open-code>). The test is run using the <open-code code="uc2/swift/test/R_utils_tests.sh" color="rgba(255,255,255,0.3)">R_utils_tests.sh</open-code> bash file. For this test, since we're using the R capabilities of Swift, we need to specify the correct <highlight-code code="uc2/swift/test/R_utils_tests.sh" color="rgba(255,255,255,0.5)" from="1" to="1"><tt id="mycode">R_HOME</tt></highlight-code> and <highlight-code code="uc2/swift/test/R_utils_tests.sh" color="rgba(255,255,255,0.5)" from="2" to="2"><tt id="mycode">LD_LIBRARY_PATH</tt></highlight-code> environment variables. Line <highlight-code code="uc2/swift/test/R_utils_tests.sh" color="rgba(255,255,255,0.3)" from="4" to="4">5</highlight-code> contains the call to the swift-t executable, specifying that the preprocessor should not be run (-p) and that additional necessary Swift files can be found one directory up (-I ..). For more details on Swift/T command line options, see the Usage section of the <a target="_blank" href="http://swift-lang.github.io/swift-t/guide.html#_usage">Swift/T website</a>. If all the <tt id="mycode">assert</tt>s pass, the script will run without error. If any of them fail, the message specified in the second argument of the failed <tt id="mycode">assert</tt> (e.g., "test2: unexpected result for calc_obj") will be displayed.
 </p>

 <p>The <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="40" to="44"><tt id="mycode">create_upfs</tt></highlight-code> function is specific to creating stochastic variations for individual parameter combinations when running Repast Simphony models. The logic for the function is implemented in an R function, also called <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="19" to="35"><tt id="mycode">create_upfs</tt></highlight-code>. A Repast Simphony parameters.xml file is read in using the <tt id="mycode">read_xml</tt> function from the R xml2 package on line <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="21" to="21">22</highlight-code>. The full parameter names and default values are both collected into a named vector <tt id="mycode">all_params_values</tt> in lines <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="22" to="25">23-26</highlight-code>. The parameter names to vary, along with their values are used to overwrite the default values in lines <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="27" to="29">28-30</highlight-code>. Finally, random seed values from 0 to <tt id="mytt">stoch_variations-1</tt> are applied to create <tt id="mycode">stoch_variations</tt> parameter combinations in lines <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="30" to="34">31-35</highlight-code>. Once the R function is defined, it is called in line <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="37" to="37">38</highlight-code>, where the arguments to the function are set in the Swift code in line <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="42" to="42">43</highlight-code> and the results are obtained in line <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="43" to="43">44</highlight-code>.
</p>
<p>The <highlight-code code="uc2/swift/test/R_utils_tests.swift" color="rgba(255,255,255,0.3)" from="6" to="17"><tt id="mycode">test1</tt></highlight-code> function in R_utils_tests.swift is used to test <highlight-code code="uc2/swift/R_utils.swift" color="rgba(255,255,255,0.3)" from="40" to="44"><tt id="mycode">create_upfs</tt></highlight-code>. The test uses a test parameters file <highlight-code code="uc2/swift/test/R_utils_tests.swift" color="rgba(255,255,255,0.3)" from="8" to="8"><tt id="myf">data/test_parameters.xml</tt></highlight-code> and a subset of <highlight-code code="uc2/swift/test/R_utils_tests.swift" color="rgba(255,255,255,0.3)" from="9" to="9">parameter names</highlight-code> and corresponding <highlight-code code="uc2/swift/test/R_utils_tests.swift" color="rgba(255,255,255,0.3)" from="10" to="10">values</highlight-code> to create 3 stochastic parameter variations. The expected result is checked in line <highlight-code code="uc2/swift/test/R_utils_tests.swift" color="rgba(255,255,255,0.3)" from="16" to="16">17</highlight-code>. As an added note, since <tt id="myfn">R_utils_tests.swift</tt> is a Swift script, the <highlight-code code="uc2/swift/test/R_utils_tests.swift" color="rgba(255,255,255,0.3)" from="33" to="34">calls</highlight-code> to the two test functions are run in parallel.
 </p>

 <h2> Python DEAP model exploration code </h2>
 <p>
 The <open-code code="uc2/python/deap_ga.py"><tt id="myfn">deap_ga.py</tt></open-code> file is the Python model exploration code that controls the workflow, communicating with the <open-code code="uc2/swift/swift_run_eqpy.swift">swift_run_eqpy.swift</open-code> file via EQ/Py queues. The EQ/Py functionality is imported in line <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="11" to="11">12</highlight-code>.
 </p>
  <p>
 As was discussed in the <modal-data data="plugins/Tutorial-View/tutorial/templating.html" ref="eqpy_section">EQ/Py Subtemplate section</modal-data> of the EMEWS Templates tutorial, the python algorithm's <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="82" to="82"><tt id="mycode">run</tt></highlight-code> function is invoked when <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="115" to="115"><tt id="mycode">EQPy_init_package</tt></highlight-code> is called in <tt id="myfn">swift_run_eqpy.swift</tt>. At this point the model exploration (ME) code takes control of the workflow. The parameters for initializing the ME code is obtained by first calling <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="89" to="89"><tt id="mycode">eqpy.OUT_put</tt></highlight-code> with "Params" as the argument. This puts the "Params" string in the EQ/Py output queue. This is obtained from the output queue by <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="116" to="116"><tt id="mycode">EQPy_get</tt></highlight-code>. (Note that while the "Params" value passed at this stage was an unused dummy value, this handshake could be used to pass different types of information to and from the ME algorithm prior to the iterative steps that form the central ME functionality, which we discuss below.) The ME parameters are passed to the EQ/Py input queue via the <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="117" to="117"><tt id="mycode">EQPy_put</tt></highlight-code> call and are obtained from the EQ/Py input queue with a call to <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="90" to="90"><tt id="mycode">eqpy.IN_get</tt></highlight-code>. The Python variables <tt id="mycode">num_iter, num_pop, seed, csv_file_name</tt> are <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="93" to="93">initialized</highlight-code> by taking advantage of the Python <tt id="mycode">eval</tt> method. This simplifies passing information to the Python ME algorithm by allowing literal representations of the Python code, in this case the variable values, to be sent through the EQ/Py input queue from Swift.
 The next part of the <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="94" to="96"><tt id="mycode">run</tt></highlight-code> method involves setting the random seed and reading in data about the JZombies model parameters, parameter names, parameter types, their low and high values, from <open-code code="uc2/data/params_for_deap.csv"><tt id="myfn">params_for_deap.csv</tt></open-code> and storing them as a <a target="_blank" href="http://pandas.pydata.org">Pandas</a> dataframe.
</p>
 <p>
  The DEAP framework (<modal-data data="plugins/Tutorial-View/tutorial/refs/fortin_deap_2012.html">Fortin et al. 2012</modal-data>) makes defining and running evolutionary algorithms like GAs easy.
Our GA creates an initial population <tt id="mycode">p<span class="sub">0</span></tt> of parameter combinations, or individuals, of size <tt id="mycode">num_pop</tt> and
proceeds to iteratively generate populations <tt id="mycode">p<span class="sub">i</span></tt>, for each
generation <tt id="mycode">i</tt>, based on the evaluated performance of individuals in
the previous population <tt id="mycode">p<span class="sub">i-1</span></tt>. Each new population <tt id="mycode">p<span class="sub">i</span></tt> is
created by first selecting with replacement <tt id="mycode">num_pop</tt> individuals from
<tt id="mycode">p<span class="sub">i-1</span></tt> using a stochastic selection method (tournament selection with size 3 here). This biases <tt id="mycode">p<span class="sub">i</span></tt> to higher performing
individuals. Then the population members are mated and mutated to
create a new generation of <tt id="mycode">num_pop</tt> offspring, where both mating and
mutation probabilities are set through user defined parameters.
</p>
 <p>
  Lines <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="98" to="117">99-118</highlight-code> show how we utilized DEAP functionality to build our GA. While interested readers can look at the <a target="_blank" href="http://deap.readthedocs.io/en/master">DEAP website</a> and the <a target="_blank" href="http://deap.readthedocs.io/en/master/overview.html">DEAP Overview</a> for more information, here we highlight the EMEWS specific elements. Line <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="109" to="109">110</highlight-code> contains the crux of integrating our Python algorithm with EMEWS. Here we define the <tt id="mycode">map</tt> function within the DEAP toolbox to point to our <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="34" to="34"><tt id="mycode">queue_map</tt></highlight-code> function. The <tt id="mycode">map</tt> function in DEAP is used for abstracting the evaluation of GA populations, allowing for the use of different backends (e.g., <a target="_blank" href="http://deap.readthedocs.io/en/master/tutorials/basic/part4.html">parallel evaluation via SCOOP or multiprocessing</a>) including, in our case, a Swift backend. We modify a GA population into a string representation and send it to the EQ/Py output queue (line <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="40" to="40">41</highlight-code>). The string-ified parameters are obtained on the Swift side from the output queue in line <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="64" to="64">65</highlight-code> of <tt id="myfn">swift_run_eqpy.swift</tt>. The parameters are split, sent for concurrent evaluation, and collected into the <tt id="mycode">res</tt> variable in lines <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="85" to="97">86-98</highlight-code>, before being put into the EQ/Py input queue in line <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="98" to="98">99</highlight-code>. Back on the Python side in the <tt id="mycode">queue_map</tt> function in <tt id="myfn">deap_ga.py</tt>, the results are obtained from the input queue in line <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="41" to="41">42</highlight-code>. These results are then split and transformed into the appropriate data structure that a DEAP <tt id="mycode">map</tt> function should return (lines <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="42" to="43">43-44</highlight-code>). Thus, from the point of view of the DEAP library and its components, the EMEWS framework is completely hidden within the <tt id="mycode">queue_map</tt> function.
 </p>
<p>
Back in the <tt id="myfn">deap_ga.py</tt> <tt id="mycode">run</tt> function, after all of the relevant properties of the GA are defined, the GA is invoked in lines <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="120" to="121">121-122</highlight-code> (see <a target="_blank" href="http://deap.readthedocs.io/en/master/api/algo.html#deap.algorithms.eaSimple">eaSimple documentation</a> for further details). The iterative calls to <tt id="mycode">queue_map</tt> occur within the <tt id="mycode">eaSimple</tt> call. Once <tt id="mycode">iter</tt> evaluations of the GA population are completed, the <tt id="mycode">fitnesses</tt> are <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="123" to="123">collected</highlight-code> and the string "DONE" is put into the EQ/Py output queue. This special value is obtained on the Swift side from the output queue in line <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="64" to="64">65</highlight-code> as before, but results in a true evaluation in line <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="72" to="72">73</highlight-code>, thus leading to the loop terminating logical branch in lines <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="74" to="81">75-82</highlight-code>. In line <highlight-code code="uc2/python/deap_ga.py" color="rgba(255,255,255,0.3)" from="127" to="127">128</highlight-code> of <tt id="myfn">deap_ga.py</tt>, formatted output is pushed into the EQ/Py output queue. This data is received in line <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="74" to="74">75</highlight-code> in <tt id="myfn">swift_run_eqpy.swift</tt> and written to an output file in lines <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="76" to="78">77-79</highlight-code>. Finally, the <tt id="mycode">loop</tt> function is exited when the Swift <tt id="mycode">propagate</tt> function (see documentation on the <a target="_blank" href="http://swift-lang.github.io/swift-t/guide.html#_general">General Swift/T library</a> for more information about <tt id="mycode">propagate</tt>) generates the <tt id="mycode">void</tt> value for the <tt id="mycode">loop</tt> return variable <tt id="mycode">v</tt> in line <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="80" to="80">81</highlight-code> (the <tt id="mycode">for</tt> loop is also exited by setting the boolean variable <tt id="mycode">c</tt> to false in line <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="81" to="81">82</highlight-code>). In line <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="119" to="119">120</highlight-code> the EQ/Py resident task at location <tt id="mycode">ME</tt> is stopped and the <tt id="mycode">start</tt> function is exited when the <tt id="mycode">o</tt> return variable is set in line <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="120" to="120">121</highlight-code>. Finally, we print out a message indicating that the <tt id="mycode">ME_rank</tt> resident task completed running in line <highlight-code code="uc2/swift/swift_run_eqpy.swift" color="rgba(255,255,255,0.3)" from="167" to="167">168</highlight-code> and the workflow ends. (Note that the EQ/Py template code allows for multiple concurrent EQ/Py resident tasks to be launched, but this use case only uses one.)
</p>

 <h2> Testing Python model exploration code </h2>
<p>
Before the Python ME code is integrated into the complete Swift workflow, it is good practice (and highly recommended) to test its functionality separately. To do this we define the test file <open-code code="uc2/python/test/test_deap_ga.py">test_deap_ga.py</open-code>. The file uses the <a target="_blank" href="http://doc.pytest.org/en/latest/">pytest framework</a> which allows tests to be defined simply by creating functions with <tt id="mycode">test_</tt> prefixes. In our case we have two tests, <highlight-code code="uc2/python/test/test_deap_ga.py" color="rgba(255,255,255,0.3)" from="11" to="14"><tt id="mycode">test_create_fitnesses</tt></highlight-code> and <highlight-code code="uc2/python/test/test_deap_ga.py" color="rgba(255,255,255,0.3)" from="16" to="34"><tt id="mycode">test_run</tt></highlight-code>.
</p>
<p>
Here we focus on the <tt id="mycode">test_run</tt> function which, as the name implies, tests the <tt id="mycode">deap_ga.run</tt> function. Our intent is to test only the functionality of the Python code and we do this using the <tt id="mycode">monkeypatch</tt> pytest fixture to stub out the <highlight-code code="uc2/python/test/test_deap_ga.py" color="rgba(255,255,255,0.3)" from="32" to="32"><tt id="mycode">eqpy.OUT_put</tt></highlight-code> and <highlight-code code="uc2/python/test/test_deap_ga.py" color="rgba(255,255,255,0.3)" from="33" to="33"><tt id="mycode">eqpy.IN_get</tt></highlight-code> functions. This involves defining methods that minimally satisfy the return values of the real <tt id="mycode">eqpy.OUT_put</tt> and <tt id="mycode">eqpy.IN_get</tt> functions. For <tt id="mycode">eqpy.OUT_put</tt> this is relatively simple, as the function only takes arguments and doesn't return any. We define a <highlight-code code="uc2/python/test/test_deap_ga.py" color="rgba(255,255,255,0.3)" from="18" to="21"><tt id="mycode">mockput</tt></highlight-code> function to record the size of the string data received, split along semicolons, and record it in the <tt id="mycode">test_run.data_size</tt> variable. (Note that while the word "mock" is used throughout the test, we are defining stubs rather than mocking the behavior of the collaborators of run. Mocking in this example would involve verifying that the methods <tt id="mycode">eqpy.OUT_put</tt> and <tt id="mycode">eqpy.IN_get</tt> are called and in the expected sequence. Interested readers can look at <a target="_blank" href="http://martinfowler.com/articles/mocksArentStubs.html">Mocks Aren't Stubs</a> for more information.) Stubbing <tt id="mycode">eqpy.IN_get</tt> is a little more complicated since <tt id="myb">a)</tt> it returns values and <tt id="myb">b)</tt> we have to include the "handshake" behavior for initializing the ME parameters before the regular EQ/Py dynamics begins. To do this we create the <tt id="mycode">Mock</tt> object <highlight-code code="uc2/python/test/test_deap_ga.py" color="rgba(255,255,255,0.3)" from="31" to="31"><tt id="mycode">mockget</tt></highlight-code> and supply it with a <highlight-code code="uc2/python/test/test_deap_ga.py" color="rgba(255,255,255,0.3)" from="22" to="29"><tt id="mycode">side_effects</tt></highlight-code> function. The <tt id="mycode">side_effects</tt> function keeps track of how many times <tt id="mycode">mockget</tt> (i.e., <tt id="mycode">eqpy.IN_get</tt>) is called and behaves differently depending on if it is being called for the first time or any subsequent time. The first time it is called it returns ME initialization parameters (line <highlight-code code="uc2/python/test/test_deap_ga.py" color="rgba(255,255,255,0.3)" from="25" to="25">26</highlight-code>) and all other times it returns a string-formatted appropriate number of random fitness results (lines <highlight-code code="uc2/python/test/test_deap_ga.py" color="rgba(255,255,255,0.3)" from="27" to="29">28-30</highlight-code>). Finally, the <highlight-code code="uc2/python/test/test_deap_ga.py" color="rgba(255,255,255,0.3)" from="34" to="34"><tt id="mycode">deap_ga.run</tt></highlight-code> function is invoked. The test can be run from the <tt id="myfn">python/test</tt> directory with the command:
<pre>PYTHONPATH=..:../../ext/EQ-Py/ py.test test_deap_ga.py</pre> 

Any mistakes affecting the flow of <tt id="mycode">deap_ga.run</tt> should generate an error without needing to run the full EMEWS machinery.
</p>


