<h1 style="margin-top: 0px;">Workflow control with Python-based external algorithms</h1>
<p>

  Due to the highly non-linear relationship between ABM input parameters and model outputs,
  as well as feedback loops and emergent behaviors, large-parameter spaces of realistic ABMs
  cannot generally be explored via brute force methods, such as full-factorial experiments,
  space-filling sampling techniques, or any other a priori determined sampling schemes.
  This is where adaptive, heuristics-based approaches are useful and this is the focus of the next two use cases.
</p>

<h2> Passing parameters and simulation results to resident task</h2>
<p>
  An inversion of control (IoC) approach enabled
  by resident Python tasks in Swift/T and simple queue-based interfaces for passing
  parameters and simulation results, where a metaheuristic method (GA) is used to control a large workflow.
  Our second use case shows how this is done with the EQ/Py extension.
  The benefit of using external libraries directly is threefold.
</p>
<p>
  First, there is no need to port the logic of a model exploration method into Swift/T,
  thereby removing the (possibly prohibitive) effort overhead and the possibility
  for translation errors. Second, the latest methods from the many available
  model exploration toolkits~(e.g., those in related:modelExp)
  can be easily compared with each other for utility and performance.
  Third, the external libraries are not aware of their existence within the
  EMEWS framework, so methods developed without massively parallel computing
  resources in mind can be nonetheless utilized in such settings.
</p>


<p>
In this use case we continue with the Repast Simphony JZombies demonstration model.
For resident tasks, which retain state, the location of a worker is used so that the
algorithm state can be repeatedly accessed.
</p>
<p>
The \href{https://goo.gl/V6JTb2}{EQ/Py extension}~\cite{emews_site}
provides an interface for interacting with Python-based resident tasks at specific locations.
\CODE{deap} shows how EQ/Py is used in the current example. We import the extension in line 1.
The deap function is defined to take the arguments py_rank (a unique rank),
iters (the number of GA iterations), trials (the number of stochastic
variations per parameter combination, or individual), pop (the number of individuals in the GA population),
and seed (the random seed to use for the GA). A location ME is generated from ME_rank in line 4.
This location is passed to the EQPy_init_package call, along with a package name (deap_ga),
which loads the Python file named
  <open-code code="uc2/python/deap_ga.py">deap_ga.py</open-code>  (found by setting the appropriate PYTHONPATH environment variable),
initializes input and output queues, and starts the run function in the
 <open-code code="uc2/python/deap_ga.py">deap_ga.py</open-code>  file, before returning.
</p>
<p>
At this point the resident task is available to interact with through the EQPy_get()
and EQPy_put() calls, which get string values from and put string values into
the resident task OUT and IN queues, respectively.
The first call to EQPy\_get() (line 8) is made in order to push initialization parameters
to the resident task via EQPy_put(ME, algo_params) (line 9). Then the doDEAP() function,
to be discussed next, is called and, when it finishes executing, EQPy\_stop()
is called to shut down the resident task.
</p>
<p>
\CODE{doDEAP} shows the main DEAP workflow loop, a general pattern for
interacting with resident tasks. Unlike the \T{foreach} loop, which parallelizes
the contents of its loop, the Swift \T{for} loop iterates in a sequential fashion,
only guided by dataflow considerations.
</p>
<p>
The for loop continues until the EQPy_get()
call receives a message ``FINAL'', at which point EQPy_get() is called again to
retrieve the final results and doDEAP() exits the loop and returns (lines 12-15).
Otherwise, the next set of parameters is obtained by splitting (line 17) the string variable
retrieved on line 10.
</p>
<p>
The contents of the pop array are individual parameter combinations,
also referred to as individuals of a GA population. Each individual is then sent to a summary
objective function obj which creates trials stochastic variations of the individual,
evaluates their objective function (the number of Humans remaining, the count_humans R
code from \CODE{zombies_max_1}) and returns the average value, (not shown here,
\href{https://goo.gl/x9V23n}{full script}~[\cite{emews_site}] on tutorial website).
Lines 25-29 transform the summary objective results for each individual into a
string representation that can be evaluated within the Python resident task,
and this value is sent to it via EQPy\_put() (line 30).
</p>
<p>
  The EQ/Py extension makes two functions, IN_get and OUT_put,
  available for the Python resident task and these can be used to pass candidate
  parameters to and get results from any Swift/T workflow. These functions are the
  complements to the EQPy_get() and EQPy_put() functions on the Swift/T side.

  </p>
  <p>
  The DEAP framework provides flexibility in defining custom components for its
  GA algorithms and we take advantage of this by overriding the map() function
  used to pass candidate parameters for evaluation to our custom  evaluator
  with toolbox.register("map", queue_map). The queue_map function
  executes calls to OUT_put and IN_get. In this way the Python
  resident task is unaware of being a component in an EMEWS workflow.
  The full Python resident task code (<open-code code="uc2/python/deap_ga.py">deap_ga.py</open-code>)
  along with the full DEAP use case can be found in the \href{https://goo.gl/rl6bwo}
  {Use Case Two  (UC2) project}~\cite{emews_site}.
</p>
