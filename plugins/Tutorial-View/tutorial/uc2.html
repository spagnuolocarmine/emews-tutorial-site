<h1 style="margin-top: 0px;">Workflow control with Python-based external algorithms</h1>
<style>
  #myol {
    margin-left: 5%;
    list-style: none outside none;
  }
  #myol li {
    counter-increment: item;
    list-style-type: none;
    margin-bottom: 5px;
  }
  #myol li:before {
    margin-right: 10px;
    content: counter(item)")";
    color: white;
    text-align: center;
    display: inline-block;
  }

</style>

<style>
  #mytt {
    font-family:'Lucida Console', monospace;
  }
</style>

<p>

  Due to the highly non-linear relationship between ABM input parameters and model outputs,
  as well as feedback loops and emergent behaviors, large-parameter spaces of realistic ABMs
  cannot generally be explored via brute force methods, such as full-factorial experiments,
  space-filling sampling techniques, or any other a priori determined sampling schemes.
  This is where adaptive, heuristics-based approaches for model exploration (ME) are useful and this is the focus of the next two use cases.
</p>
<p>
In (<modal-data data="plugins/Tutorial-View/tutorial/refs/ozik_many_2015.html">Ozik, Collier, and Wozniak 2015</modal-data>)
  we describe an inversion of control (IoC) approach enabled by resident Python tasks in Swift/T and simple
  queue-based interfaces for passing parameters and
  simulation results, where a metaheuristic method, a genetic algorithm (GA),
  is
  used to control a large workflow. This workflow structure was made more general and resulted in the EMEWS framework. 
  In this second use case we describe how this IoC workflow is implemented with the EQ/Py extension. The following is the overall EMEWS workflow structure for this use case.
</p>
<p>
  <img src="plugins/Tutorial-View/tutorial/img/EMEWS_figure_UC2.png" alt="EMEWS Figure UC2" height="300">
</p>

<p>
We use a GA model exploration module developed with the Python DEAP library (<modal-data data="plugins/Tutorial-View/tutorial/refs/fortin_deap_2012.html">Fortin et al. 2012</modal-data>). We also use the same Java-based JZombies model from the <modal-data data="plugins/Tutorial-View/tutorial/uc1.html" ref="jzombies">Use Case 1 Tutorial</modal-data>. The GA is used to automatically discover the best input parameter combinations which yield the maximum number of surviving humans. For each parameter combination, this "fitness" metric is calculated by averaging over a number of stochastic variations. Unlike the example presented in <modal-data data="plugins/Tutorial-View/tutorial/uc1.html" ref="finding_best">Use Case 1 Tutorial</modal-data>, we aren't specifying an a priori set of parameter combinations for evaluation. Rather, we are using the GA heuristic to dynamically explore the input parameter space of the JZombies model. With EMEWS, this model exploration (ME) can be done at scale, without needing to modify either the ME code or the model code.
</p>

<h2> EQ/Py with EMEWS </h2>
<!-- 
<p>
  Resident tasks, which retain state, are accessed via their worker location so that the
algorithm state can be repeatedly accessed.
</p>
 -->

<p>
  One unique aspect of the EMEWS framework is its ability to directly incorporate external libraries or code that implements model exploration algorithms. The benefit of using external libraries directly is threefold:
</p>
<p>
<ol id="myol">
            <li>There is no need to port the logic of a model exploration method into Swift/T,
  thereby removing the (possibly prohibitive) effort overhead and the possibility
  for translation errors.</li>
            <li>The latest methods from the many available
  model exploration toolkits (e.g., those in Section 2.2 of the <modal-data data="plugins/Tutorial-View/tutorial/refs/ozik_emews_2016.html">EMEWS Tutorial</modal-data>)
  can be easily compared with each other for utility and performance.</li>
            <li>The external libraries are not aware of their existence within the
  EMEWS framework, so methods developed without massively parallel computing
  resources in mind can be nonetheless utilized in such settings.</li>
          </ol>
</p>


<p>
As was discussed in the <modal-data data="plugins/Tutorial-View/tutorial/templating.html" ref="eqpy_section">EQ/Py section</modal-data> of the EMEWS Template tutorial, the EQ/Py extension provides an interface for interacting with Python-based resident tasks
at specific locations. The code that we present in this use case is directly adapted from the EQ/Py subtemplate, so readers who have completed the EMEWS Templates tutorial will already be familiar with the directory structure and template code. 

<h3> EQ/Py swift script </h3>
<p>
The <open-code code="uc2/swift/swift_run_eqpy.swift"><tt id="mytt">swift_run_eqpy.swift</tt></open-code> file is the main swift file generated for the EQ/Py subtemplate. Here we discuss how this template file was modified for the current example.
</p>

<ul>
<li>Starting from lines <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="148" to="152">149-153</highlight-code> in the main function, we've modified the command line arguments that are sent to the swift script. </li>
 
<li>The <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="134" to="136"><tt id="mytt">run_prerequisites</tt></highlight-code> Swift function was implemented, using the same functionality as <modal-data data="plugins/Tutorial-View/tutorial/uc1.html" ref="utility_functions">cp_message_center in UC1</modal-data>. </li>
 
 <li>The arguments passed to the <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="103" to="104"><tt id="mytt">start</tt></highlight-code> function were modified to reflect the new information that is passed in via the command line.</li>

 <li>The <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="114" to="114"><tt id="mytt">algo_params</tt></highlight-code> string variable, which contains the information for initializing the Python resident task, was modified.</li>

<li> In the <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="54" to="54"><tt id="mytt">loop</tt></highlight-code> function the <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="55" to="57"><tt id="mytt">param_names</tt></highlight-code> string variable is added to track which parameters are being explored by the GA. This allows us to specify the subset of model parameters to explore.
 
 <li> In the <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="42" to="42"><tt id="mytt">obj</tt></highlight-code> function we call the <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="44" to="44"><tt id="mytt">create_upfs</tt></highlight-code> function (defined in a separate swift file <highlight-code code="uc2/swift/R_utils.swift"
 color="rgba(255,255,255,0.3)" from="40" to="44">R_utils.swift</highlight-code>, discussed below) to generate stochastic variations of individual parameter combinations. These are stored in the string variable <tt id="mytt">upfs</tt> as semicolon separated sets of parameters. The string array <tt id="mytt">parameter_combos</tt> is created by <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="45" to="45">splitting</highlight-code> <tt id="mytt">upfs</tt> using semicolons as delimiters. Once the parameter combinations are <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="48" to="48">evaluated</highlight-code>, their average is <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="51" to="51">calculated</highlight-code>.
</li>

<li>In the <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="27" to="27"><tt id="mytt">run_obj</tt></highlight-code> function we removed the <tt id="mytt">out</tt> and <tt id="mytt">err</tt> files for tracking stdout and stderr (these can be included for debugging purposes). We define the path to the <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="32" to="32">script file</highlight-code> to run our model. Finally, we call the <highlight-code code="uc2/swift/swift_run_eqpy.swift"
 color="rgba(255,255,255,0.3)" from="35" to="35"><tt id="mytt">calc_obj</tt></highlight-code> function (also defined in <highlight-code code="uc2/swift/R_utils.swift"
 color="rgba(255,255,255,0.3)" from="9" to="14">R_utils.swift</highlight-code> and discussed below) to calculate the fitness of the parameter combination <tt id="mytt">param_line</tt>.</li>

</ul>

<h3> R_utils swift script and swift script testing </h3>
<p>
The <open-code code="uc2/swift/R_utils.swift"
 color="rgba(255,255,255,0.3)">R_utils.swift</open-code> file was used to define utility functions used in the <open-code code="uc2/swift/swift_run_eqpy.swift">swift_run_eqpy.swift</open-code> file. The two functions implemented are <highlight-code code="uc2/swift/R_utils.swift"
 color="rgba(255,255,255,0.3)" from="9" to="14"><tt id="mytt">calc_obj</tt></highlight-code> and <highlight-code code="uc2/swift/R_utils.swift"
 color="rgba(255,255,255,0.3)" from="40" to="44"><tt id="mytt">create_upfs</tt></highlight-code>.
</p>

<!-- <h4> <tt id="mytt">calc_obj</tt> </h4> -->
The <highlight-code code="uc2/swift/R_utils.swift"
 color="rgba(255,255,255,0.3)" from="9" to="14"><tt id="mytt">calc_obj</tt></highlight-code> function is implemented just like the counting of humans was implemented in the <modal-data data="plugins/Tutorial-View/tutorial/uc1.html" ref="gather_results">Gathering the Results</modal-data> section of the Use Case 1 Tutorial. The only difference is that all of the relevant code is captured within the <highlight-code code="uc2/swift/R_utils.swift"
 color="rgba(255,255,255,0.3)" from="9" to="14"><tt id="mytt">calc_obj</tt></highlight-code> function and that this function is individually tested in 
<highlight-code code="uc2/swift/test/R_utils_tests.swift"
 color="rgba(255,255,255,0.3)" from="20" to="31"><tt id="mytt">test2</tt></highlight-code> in R_utils_tests.swift. In a multi-module and multi-language setting like EMEWS, it is crucial for separate modules to be tested individually before all of the components are assembled into a single workflow. For testing Swift code, the <highlight-code code="uc2/swift/test/R_utils_tests.swift"
 color="rgba(255,255,255,0.3)" from="24" to="24"><tt id="mytt">assert</tt></highlight-code> keyword is used to ensure that the expected results are returned from executing the code being tested. 
The <tt id="mytt">test2</tt> function contains three separate tests to exercise the <tt id="mytt">calc_obj</tt> function. Each of these tests is passed a different path to a test data folder (data, data/d1, and data/d2), each containing three separate counts.csv files (<open-code code="uc2/swift/test/data/counts.csv"
 color="rgba(255,255,255,0.3)">data/counts.csv</open-code>, <open-code code="uc2/swift/test/data/d1/counts.csv"
 color="rgba(255,255,255,0.3)">data/d1/counts.csv</open-code>, and <open-code code="uc2/swift/test/data/d2/counts.csv"
 color="rgba(255,255,255,0.3)">data/d2/counts.csv</open-code>). The test is run using the <open-code code="uc2/swift/test/R_utils_tests.sh"
 color="rgba(255,255,255,0.3)">R_utils_tests.sh</open-code> bash file. For this test, since we're using the R capabilities of Swift, we need to specify the correct <highlight-code code="uc2/swift/test/R_utils_tests.sh"
 color="rgba(255,255,255,0.5)" from="1" to="1"><tt id="mytt">R_HOME</tt></highlight-code> and <highlight-code code="uc2/swift/test/R_utils_tests.sh"
 color="rgba(255,255,255,0.5)" from="2" to="2"><tt id="mytt">LD_LIBRARY_PATH</tt></highlight-code> environment variables. Line <highlight-code code="uc2/swift/test/R_utils_tests.sh"
 color="rgba(255,255,255,0.3)" from="4" to="4">5</highlight-code> contains the call to the swift-t executable, specifying that the preprocessor should not be run (-p), and that additional necessary Swift files can be found one directory up (-I ..). 

 
<br>
<br><br><br><br><br><br><br><br><br><br>
The deap function is defined to take the arguments py_rank (a unique rank),
iters (the number of GA iterations), trials (the number of stochastic
variations per parameter combination, or individual), pop (the number of individuals in the GA population),
and seed (the random seed to use for the GA). A location ME is generated from ME_rank in line 4.
This location is passed to the EQPy_init_package call, along with a package name (deap_ga),
which loads the Python file named
  <open-code code="uc2/python/deap_ga.py">deap_ga.py</open-code>  (found by setting the appropriate PYTHONPATH environment variable),
initializes input and output queues, and starts the run function in the
 <open-code code="uc2/python/deap_ga.py">deap_ga.py</open-code>  file, before returning.
</p>
<p>
At this point the resident task is available to interact with through the EQPy_get()
and EQPy_put() calls, which get string values from and put string values into
the resident task OUT and IN queues, respectively.
The first call to EQPy\_get() (line 8) is made in order to push initialization parameters
to the resident task via EQPy_put(ME, algo_params) (line 9). Then the doDEAP() function,
to be discussed next, is called and, when it finishes executing, EQPy\_stop()
is called to shut down the resident task.
</p>
<p>
\CODE{doDEAP} shows the main DEAP workflow loop, a general pattern for
interacting with resident tasks. Unlike the \T{foreach} loop, which parallelizes
the contents of its loop, the Swift \T{for} loop iterates in a sequential fashion,
only guided by dataflow considerations.
</p>
<p>
The for loop continues until the EQPy_get()
call receives a message ``FINAL'', at which point EQPy_get() is called again to
retrieve the final results and doDEAP() exits the loop and returns (lines 12-15).
Otherwise, the next set of parameters is obtained by splitting (line 17) the string variable
retrieved on line 10.
</p>
<p>
The contents of the pop array are individual parameter combinations,
also referred to as individuals of a GA population. Each individual is then sent to a summary
objective function obj which creates trials stochastic variations of the individual,
evaluates their objective function (the number of Humans remaining, the count_humans R
code from \CODE{zombies_max_1}) and returns the average value, (not shown here,
\href{https://goo.gl/x9V23n}{full script}~[\cite{emews_site}] on tutorial website).
Lines 25-29 transform the summary objective results for each individual into a
string representation that can be evaluated within the Python resident task,
and this value is sent to it via EQPy\_put() (line 30).
</p>
<p>
  The EQ/Py extension makes two functions, IN_get and OUT_put,
  available for the Python resident task and these can be used to pass candidate
  parameters to and get results from any Swift/T workflow. These functions are the
  complements to the EQPy_get() and EQPy_put() functions on the Swift/T side.

  </p>
  <p>
  The DEAP framework provides flexibility in defining custom components for its
  GA algorithms and we take advantage of this by overriding the map() function
  used to pass candidate parameters for evaluation to our custom  evaluator
  with toolbox.register("map", queue_map). The queue_map function
  executes calls to OUT_put and IN_get. In this way the Python
  resident task is unaware of being a component in an EMEWS workflow.
  The full Python resident task code (<open-code code="uc2/python/deap_ga.py">deap_ga.py</open-code>)
  along with the full DEAP use case can be found in the \href{https://goo.gl/rl6bwo}
  {Use Case Two  (UC2) project}~\cite{emews_site}.
</p>
