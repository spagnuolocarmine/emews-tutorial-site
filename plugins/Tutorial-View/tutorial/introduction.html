
<h1 style="margin-top: 0px;"> Introduction</h1>

<style>
  #myi {
    font-style: italic;
  }
</style>

<style>
  #myb {
    font-weight: bold;
  }
</style>

<style>
  #mytt {
    font-family:'Lucida Console', monospace;
  }
</style>

<style>
  #myol {
    margin-left: 5%;
    list-style: none outside none;
  }
  #myol li {
    counter-increment: item;
    list-style-type: none;
    margin-bottom: 5px;
  }
  #myol li:before {
    margin-right: 10px;
    content: counter(item)")";
    color: white;
    text-align: center;
    display: inline-block;
  }

</style>

<h2>Navigating the Tutorial</h2>

Before we begin, here's an orientation for how the tutorial works. The tutorial window is composed of 5 panes.

<p>
  <img src="plugins/Tutorial-View/tutorial/img/tutorial_window.png" alt="Tutorial Window" height="400" width="600">
</p>

<p>
The tutorial text appears in pane 1 (see the image above). Within the tutorial text
you will see hyperlinks to source code that is being explained. These links are
of two types. Both types will display the content of the relevant source code file in pane 2. The
second type will also scroll the source code and highlight lines of interest.
For example, clicking on this link:
<open-code code="uc1/swift/swiftrun.swift">swiftrun.swift</open-code>
will open the <tt id="mytt">swiftrun.swift</tt> file in pane 2, and clicking
on this <highlight-code code="uc1/swift/swiftrun.swift"
color="rgba(255,255,255,0.3)" from="12" to="14">one</highlight-code> will scroll
and highlight lines 13-15 in that file. Other links refer to sections
in other tutorials, or bibliographic references. These will appear as a modal browser window, displaying
the relevant text. To dismiss the window, click the X at the top right corner of the window or just hit the Esc key.
(Note that you may have to scroll the modal window's content to the top
for the X to appear. The place-marker icon to the left of the X can be used to move the modal window.) Click this reference link
<modal-data data="plugins/Tutorial-View/tutorial/refs/rj_getting_started.html">Nick Collier and Michael North 2015</modal-data>
as an example.
</p>

<p>
  The source code pane (pane 2) can be minimized by clicking the arrow at the
  top of the source pane.</p>
  <p>
    <img src="plugins/Tutorial-View/tutorial/img/source_header.png" alt="Source Header" width="600">
  </p>

  <p>
  Clicking the arrow again will restore the source pane. The slider at
  the bottom of the source pane can be used to change its height (see figure).
  <p>
    <img src="plugins/Tutorial-View/tutorial/img/source_slider.png" alt="Source Slider" width="600">
  </p>
</p>

<p>
  The button next to the slider can be used to remove highlights from code.
  <p>
    <img src="plugins/Tutorial-View/tutorial/img/source_remove_highlights.png" alt="Source Remove Highlights" width="600">
  </p>
</p>

<p>
Pane 3 displays the source files and project structure for the tutorial
currently displayed in pane 1. Double-clicking a folder or single-clicking the 
triangle symbol to the left of the folder will reveal its contents.
  <p>
    <img src="plugins/Tutorial-View/tutorial/img/explore_folder.png" alt="Explore Folder" width="300">
  </p>

Double-clicking on a file will display it in pane 2.

  <p>
    <img src="plugins/Tutorial-View/tutorial/img/explore_file.png" alt="Explore File" width="300">
  </p>

</p>

<p>
Pane 4 displays a table of contents for the current tutorial. Single click on an entry to scroll
the tutorial text in pane 1 to that section.
</p>

<p>
  Pane 5 displays the list of tutorials. Double click on an entry to open
  that tutorial.
</p>

<p>
If you leave the tutorial and come back to it, you will be placed into the last section you were in when you left.
The tutorial can be reset back to the introduction by clicking on the top right globe icon 
and choosing the refresh icon in the displayed window.
<p>
    <img src="plugins/Tutorial-View/tutorial/img/globe.png" alt="Source Header" width="300">
  </p>
You can click the home icon to return to the title page of the tutorial as well.
</p>
<h2>Extreme-scale Model Exploration with Swift (EMEWS)</h2>
<p>
<b id="myb">Modern simulation-based application studies are campaigns</b>
consisting of large numbers of simulations with many possible
variations.  Simulations may be run with different parameters,
possibly as part of an automated model parameter optimization,
classification, or, more generally, <i id="myi">model exploration</i> (ME). Constructing the software to run
such studies at the requisite computational scales is often unnecessarily time-consuming and the resulting
software artifacts are typically difficult to generalize and
package for other users.
</p>

<p>
In this tutorial, we present a solution for many of the challenges in
running large-scale simulation studies.  Our framework, Extreme-scale Model
Exploration with Swift/T (<b>EMEWS</b>), uses the general-purpose parallel
scripting language Swift
(<modal-data data="plugins/Tutorial-View/tutorial/refs/STC_2014.html">Armstrong et al. 2014</modal-data>) to generate highly
concurrent simulation workflows.  These workflows enable the integration of
external ME algorithms to coordinate the running and evaluation of large numbers of simulations.  The general-purpose nature of
the programming model allows the user to supplement the workflows with additional
analysis and post-processing as well.
</p>
<p>
Here, we focus on agent-based models (ABMs).  Extracting
knowledge from ABMs requires the use of approximate, heuristic ME methods involving large simulation ensembles. To improve the current state of the art it has been noted elsewhere that: “...
there is a clear need to provide software frameworks for
metaheuristics that promote software reuse and reduce developmental
effort” (<modal-data data="plugins/Tutorial-View/tutorial/refs/boussaid_survey_2013.html">Boussaid 2013</modal-data>). Our design goals are to ease
software integration while providing scalability to the largest scale
(petascale plus) supercomputers, running millions of ABMs, thousands
at a time. Initial scaling studies of <b id="myb">EMEWS</b> have shown robust scalability
(<modal-data data="plugins/Tutorial-View/tutorial/refs/ozik_many_2015.html">Ozik et al. 2015</modal-data>). The tools are also easy to install and run on an ordinary
laptop, requiring only an MPI (Message Passing Interface) implementation, which can be easily
obtained from common OS package repositories.
</p>

<!-- 
<ul>
<li> powerful</li>
<li> efficient (mention that performance was measured in MTAGS and SC submission, and indicate weak scaling results from SC)</li>
<li> re-usable</li>
</ul>
 -->

<h3> EMEWS workflow structure </h3>
<p>
<img src="plugins/Tutorial-View/tutorial/img/EMEWS_figure.png" alt="EMEWS Figure" height="300">
</p>



<p>
This figure illustrates the main components of the <b id="myb">EMEWS</b>
framework.  The main user interface is the Swift script, a high-level
program.  The core novel contributions of
<b id="myb">EMEWS</b> are shown in green, these allow the Swift script to access a
running ME algorithm.  This algorithm can be expressed in Python, R, C, C++,
Fortran, Julia, Tcl, or any language supported by Swift/T.  We provide
a high-level queue-like interface with (currently) two
implementations: EQ/Py and EQ/R (EMEWS Queues for
Python and R).  These allow the Swift script to obtain
candidate model parameter inputs and return model outputs to the ME.  The
simulation models are distributed by the Swift/T runtime over a
potentially large computer system, but smaller systems that run one
model at a time are also supported.  The simulations can be
implemented as external applications called through the shell, or
in-memory libraries accessed directly by Swift (for faster
invocation).
</p>
<p>
<b id="myb">EMEWS</b> thus offers the following contributions to the science and
practice of simulation ME studies: <!-- 
<b id="myb">1)</b> it offers the capability to run very large, highly concurrent
  ensembles of simulations of varying types; <b id="myb">2)</b> it supports a wide class of model exploration algorithms,
  including those increasingly available to the community via Python and R libraries; and <b id="myb">3)</b> it offers a software sustainability solution, in that simulation
  studies based around <b id="myb">EMEWS</b> can easily be compared and
  distributed.
 -->

<ol id="myol">
<li> It offers the capability to run very large, highly concurrent
  ensembles of simulations of varying types;</li>
<li> It supports a wide class of model exploration algorithms,
  including those increasingly available to the community via Python and R libraries;</li>
<li> It offers a software sustainability solution, in that simulation
  studies based around <b id="myb">EMEWS</b> can easily be compared and
  distributed.</li>
</ol>
</p>

<h2> Tutorial Goals</h2>
<p>
Our tutorial will present these contributions in more detail.  The
examples use cases presented in this paper are generally runnable
Swift (not pseudocode) and are published on a <a target="_blank" href="https://goo.gl/Wia9Rm">public repository</a>.
<p>
</p>
<b id="myb">TODO</b>: Include mention of downloadable UC1-3 archives.
</p>

<!--
<p>
The remainder of this paper is organized as follows.  In \SLF{related},
we describe related ABM software, ME libraries, and workflow
toolkits.  In \SLF{swift}, we describe the Swift programming model in
detail with examples.  In \SLF{usecases}, we provide complete use
cases in the ABM context.  We summarize our contributions
in \SLF{summary}.
</p>
-->
