
<h1 style="margin-top: 0px;"> INTRODUCTION</h1><br>

<style>
  #myi {
    font-style: italic;
  }
</style>

<style>
  #myb {
    font-weight: bold;
  }
</style>

<style>
  #mytt {
    font-family:'Lucida Console', monospace;
  }
</style>


<h2>Navigating the Tutorial</h2>

The tutorial window is composed of 5 panes.

<p>
  <img src="plugins/Tutorial-View/tutorial/img/tutorial_window.png" alt="Tutorial Window" height="400" width="600">
</p>

<p>
The tutorial text appears in pane 1 (see the image above). Within in the text
you will see hyperlinks to source code discussed in the text. These links are
of two types. Both types will display the source code file in pane 2. The
second type will scroll the source code and highlight lines of interest.
For example, clicking on this link:
<open-code code="uc1/swift/swiftrun.swift">swiftrun.swift</open-code>
will open the <tt id="mytt">swiftrun.swift</tt> file in pane 2, and clicking
on this <highlight-code code="uc1/swift/swiftrun.swift"
color="rgba(255,255,255,0.3)" from="12" to="14">one</highlight-code> will scroll
and highlight lines 13-15 in that file in pane 2. Other links refer to sections
from other tutorials, or bibliographic references. These will appear as a modal browser window, displaying
the relevant text. To dismiss the window, click the X at the top right corner.
Note that you may have to scroll the modal window's content to the top
for the X to appear. Click this reference link
<modal-data data="plugins/Tutorial-View/tutorial/refs/rj_getting_started.html">Nick Collier and Michael North 2015</modal-data>
as example.
</p>

<p>
  The source code pane (pane 2) can be minimized by clicking the arrow at the
  top of the source pane. See the image below.</p>
  <p>
    <img src="plugins/Tutorial-View/tutorial/img/source_header.png" alt="Source Header" width="600">
  </p>

  <p>
  Clicking the arrow again will restore with the source pane. The slider at
  the bottom of the source pane can be used to change the height of the
  source pane.
</p>

<p>
Pane 3 displays the source files and project structure for the tutorial
currently displayed in pane 1. From within that pane you can open folders
and display files in pane 2 by double clicking on the file.
</p>

<p>
Pane 4 displays a table of contents for the for the tutorial
currently displayed in pane 1. Single click on the entries to scroll
the tutorial text in pane 1 to that entry.
</p>

<p>
  Pane 5 displays the list of tutorials. Double click on an entry to open
  that tutorial.
</p>

<p>
<b id="myb">Modern simulation-based application studies are campaigns</b>
consisting of large numbers of simulations with many possible
variations.  Simulations may be run with different parameters,
possibly as part of an automated model parameter optimization,
classification, or, more generally, <i id="myi">model exploration</i> (ME). Constructing the software to run
such studies at the requisite computational scales is often unnecessarily time-consuming and the resulting
software artifacts are typically difficult to generalize and
package for other users.
</p>

<p>
In this tutorial, we present a solution for many of the challenges in
running large-scale simulation studies.  Our framework, Extreme-scale Model
Exploration with Swift/T (<b>EMEWS</b>), uses the general-purpose parallel
scripting language Swift
(<modal-data data="plugins/Tutorial-View/tutorial/refs/STC_2014.html">Armstrong et al. 2014</modal-data>) to generate highly
concurrent simulation workflows.  These workflows enable the integration of
external ME algorithms to coordinate the running and evaluation of large numbers of simulations.  The general-purpose nature of
the programming model allows the user to supplement the workflows with additional
analysis and post-processing as well.
</p>
<p>
Here, we focus on agent-based models (ABMs).  Extracting
knowledge from ABMs requires the use of approximate, heuristic ME methods involving large simulation ensembles. To improve the current state of the art it has been noted elsewhere that: “...
there is a clear need to provide software frameworks for
metaheuristics that promote software reuse and reduce developmental
effort.”
(<modal-data data="plugins/Tutorial-View/tutorial/refs/boussaid_survey_2013.html">Boussaid 2013</modal-data>) Our design goals are to ease
software integration while providing scalability to the largest scale
(petascale plus) supercomputers, running millions of ABMs, thousands
at a time. Initial scaling studies of <b id="myb">EMEWS</b> have shown robust scalability
(<modal-data data="plugins/Tutorial-View/tutorial/refs/ozik_many_2015.html">Ozik et al. 2015</modal-data>). The tools are also easy to install and run on an ordinary
laptop, requiring only an MPI (Message Passing Interface) implementation, which can be easily
obtained from common OS package repositories.

<ul>
<li> powerful</li>
<li> efficient (mention that performance was measured in MTAGS and SC submission, and indicate weak scaling results from SC)</li>
<li> re-usable</li>
</ul>

WOZNIAK TODO <img src="img/EMEWS-loop"/>
Overview of Extreme-scale Model Exploration with Swift/T (EMEWS) framework.
</p>

<p>
This figure illustrates the main components of the <b id="myb">EMEWS</b>
framework.  The main user interface is the Swift script, a high-level
program.  The core novel contributions of
<b id="myb">EMEWS</b> are shown in green, these allow the Swift script to access a
running ME algorithm.  This algorithm can be expressed in Python, R, C, C++,
Fortran, Julia, Tcl, or any language supported by Swift/T.  We provide
a high-level queue-like interface with (currently) two
implementations: EQ/Py and EQ/R (EMEWS Queues for
Python and R).  These allow the Swift script to obtain
candidate model parameter inputs and return model outputs to the ME.  The
simulation models are distributed by the Swift/T runtime over a
potentially large computer system, but smaller systems that run one
model at a time are also supported.  The simulations can be
implemented as external applications called through the shell, or
in-memory libraries accessed directly by Swift (for faster
invocation).
</p>
<p>
<b id="myb">EMEWS</b> thus offers the following contributions to the science and
practice of simulation ME studies: <b id="myb">1)</b> it offers the capability to run very large, highly concurrent
  ensembles of simulations of varying types; <b id="myb">2)</b> it supports a wide class of model exploration algorithms,
  including those increasingly available to the community via Python and R libraries; and <b id="myb">3)</b> it offers a software sustainability solution, in that simulation
  studies based around <b id="myb">EMEWS</b> can easily be compared and
  distributed.

<ul>
<li> It offers the capability to run very large, highly concurrent
  ensembles of simulations of varying types;</li>
<li> It supports a wide class of model exploration algorithms,
  including those increasingly available to the community via Python and R libraries;</li>
<li> It offers a software sustainability solution, in that simulation
  studies based around <b id="myb">EMEWS</b> can easily be compared and
  distributed.</li>
</ul>
</p>
<h2> Tutorial Goals</h2>
<p>
Our tutorial will present these contributions in more detail.  The
examples use cases presented in this paper are generally runnable
Swift (not pseudocode) and are published on a <a href="https://goo.gl/Wia9Rm">public repository</a>.
</p>

<!--
<p>
The remainder of this paper is organized as follows.  In \SLF{related},
we describe related ABM software, ME libraries, and workflow
toolkits.  In \SLF{swift}, we describe the Swift programming model in
detail with examples.  In \SLF{usecases}, we provide complete use
cases in the ABM context.  We summarize our contributions
in \SLF{summary}.
</p>
-->
